# angular-golang

### General
The goal was to create a code template with:

* A modern backend language like Golang
* A modern frontend framework like Angular
* Frontend and backend deployed as single and small docker containers

This project is primarily intended as a template for small to medium sized projects, although it should be easy to transform it into a setup more suitable for larger projects by splitting it into separate frontend and backend containers.

The size of the resulting docker container is only ~17 MB, consisting of 

* Slim Nginx Alpine image (11.5 MB)
* Golang backend (4.5 MB)
* Angular resources (< 1 MB)



## Usage

### Installation Requirements

* Golang 1.20
* Node.js 18
* Angular 16



### Production

```bash
cd docker 
bash build-and-run.sh
```

Visit http://localhost, click on the "Click me" button and you should see a message saying "Hello from Golang Backend!".



### Development

There are two terminals necessary for the start of the two different processes. In the first terminal, run these commands:

```bash
cd src/frontend
ng serve
```

In the second terminal, run these commands:

```bash
cd src/backend
go run main.go
```

Visit http://localhost:4200 and do the same as above.

Alternatively, you can run the frontend and backend from your favourite IDE.



## Technical Explanations

### Role of Nginx

Building Angular generates a small set of static web resources for the Docker container that browsers can fetch by sending requests to Nginx. The same Nginx instance is responsible for redirecting requests with the '/api' path prefix to the Golang backend, which is why the container is so small.



### Angular Adaptions

The Angular source code is mostly the standard code generated by the 'ng new' command. The only notable changes are the implementation of the request to the backend and the addition of the environments. If Angular is deployed for production in a Docker container, all traffic will go through Nginx on `localhost:80`. If Angular is deployed locally for development, there is no Nginx service and the Golang backend is exposed on `localhost:8080`, so requests from the frontend should be sent there instead. This configuration snippet in `angular.json` allows the above differentiation by defining a different configuration file for production purposes.

```json
"configurations": {
  "production": {
    "fileReplacements": [
      {
        "replace": "src/environments/environment.ts",
        "with": "src/environments/environment.prod.ts"
      }
  ],
```



### CORS

When developing and loading the frontend code from `localhost:4200`, the request to the backend to `localhost:8080` would have caused an error due to the browser's CORS policy if it had not been explicitly disabled in the Golang backend for ease of development. Although CORS is enabled in the Docker container as it should be, this should be taken into account when developing based on this code template.



### Two Processes in One Docker Container

Running `docker/build-and-run.sh` starts the Docker container in interactive mode, so the developer can see the printed output in the terminal. The `docker/entrypoint.sh` starts two processes, the Nginx process for the frontend and the Golang process for the backend. Normally, when you exit interactive mode in docker, the entrypoint process is killed. This means that creating child processes in bash with a trailing `&`, as in the backend startup command `/usr/bin/backend prod &`, would normally result in processes that are not terminated when the Docker interactive mode is exited, causing the container to continue running. Therefore, the `trap` command in `entrypoint.sh` is used to send termination signals to these processes so that the Docker container can shut down completely when the interactive mode is exited.

The terminal output of the Docker container prints both the Nginx and Goland backend logs. It is recommended that potential backend logs are clearly marked as such for ease of differentiation.